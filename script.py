# main: 写一个大while一直循环阶段方法+ui
# module: 类,数据,规则,阶段方法
# sz_index: 结算方法
# ai
# data: 4(5？) 个csv

# 因为传递参数很混乱 我都给写在这个script里了
'''
几个问题：
1. 有一部分方法还不全/有bug 需要写一些test
2. 输入全用的input(),希望能改成按钮触发式的; 所有操作都不能反悔,希望能加上撤销或者能打草稿
3. 类写的太烂 参数传递很混乱 完全是用到啥写啥
    3.1 导致好多数据/list越堆越厚
    3.2 不易读/不易改
4. 因为需要遍历+埏埴数量太多 真正的ai比我原来写的toy数据上复杂的多。需要扩充规则方法+在操作前先建可行的操作对象的列表/字典
    4.1 我把ai和玩家设定为同一个级别了 但ai文件做不到玩家的input 感觉似乎应该写进module里?
5. ai只能下2埏埴和3.1/3.2的棋子而且打不出原本设计的combo,要增加能动态计算风险/加成的方法(或者让ai就这么傻着/改棋子表取消乱七八糟的操作)
6. ui好麻烦 unity/c++会容易一些吗
'''

import csv
import sz_index #埏埴csv格子exec

棋子表1=list(csv.reader(open('data/棋子表1.csv','r',encoding='UTF-8-sig'))) # 读取玩家棋子表 而非完整棋子表 测试用的全部
棋子表2=list(csv.reader(open('data/棋子表2.csv','r',encoding='UTF-8-sig'))) # 可以根据级别分？

埏埴表=list(csv.reader(open('data/埏埴表.csv','r',encoding='UTF-8-sig'))) # 读取完整埏埴表
#每个玩家都要分配一个单独的埏埴表 (还没做)
天元表=list(csv.reader(open('data/天元表.csv','r',encoding='UTF-8-sig'))) # 读取玩完整天元表

# 类
class 玩家:
    def __init__(self,玩家id,玩家棋子字典):
        self.玩家id=玩家id
        self.玩家棋子字典=玩家棋子字典
        self.机会=[3,1,0]

    def 下子(self,棋子,阵法):
        if 机会判断(棋子,self) and 阵法下子判断(阵法,棋子):
            机会计算(self,棋子)
            阵法.下子(棋子)
        else:
            print('棋子无效')

    def 建立阵法(self,棋子):
        id=input('阵法id:')
        while id in 场上阵法字典:
            print('重名')
            id=input('阵法id:')
        场上阵法字典[id]=阵法(天元字典[input('请输入天元id:')],id)
        场上阵法字典[id].玩家=self.玩家id
        self.下子(棋子,场上阵法字典[id])
        

class 阵法:
    def __init__(self,天元,阵法id):
        self.阵法id=阵法id
        self.棋子列表=[]
        self.气=int(天元[0])
        self.周天数=int(天元[1])
        self.周天位=0
        self.玩家=0 

    def 阵法埏埴(self):
        阵法埏埴=[]
        for 目标棋子 in self.棋子列表:
            阵法埏埴+=目标棋子.棋子埏埴()
        return 阵法埏埴

    def 下子(self,棋子):
        self.棋子列表.append(棋子)
        棋子.阵法id=self.阵法id
        for 目标埏埴 in 棋子.棋子埏埴():
            目标埏埴.阵法id=self.阵法id
        if 棋子.埏埴数==2 and 棋子.系列 in [4,5]:
            棋子阴阳=input('阴/阳: ')
            for 目标埏埴 in 棋子.棋子埏埴():
                目标埏埴.阴阳=棋子阴阳
        elif 棋子.埏埴数==3:
            for 目标埏埴 in 棋子.棋子埏埴():
                目标埏埴.阴阳='总'
        elif 棋子.埏埴数==3:
            if 棋子.系列==4:
                目标=input('指定阵法')
            elif 棋子.系列==5:
                目标=input('指定星位') #星位判定
            elif 棋子.系列==6:
                目标=input('指定埏埴') #埏埴指向参数 [阵法id,星位]

            for 目标埏埴 in 棋子.棋子埏埴():
                目标埏埴.目标=目标


class 棋子:
    def __init__(self,棋子行):
        self.阵法id=''
        self.埏埴数=int(棋子行[0])
        self.系列=int(棋子行[1])
        self.级别=int(棋子行[2])
        self.埏埴=棋子行[3:]
        while '' in self.埏埴:
            self.埏埴.remove('')


    def 棋子埏埴(self):
        棋子埏埴表=[]
        for 埏埴id in self.埏埴:
            棋子埏埴表.append(埏埴字典[埏埴id])
        return 棋子埏埴表

class 埏埴:
    def __init__(self,埏埴行):
        self.阴阳=''
        self.阵法id=''
        self.埏埴id=埏埴行[0]
        self.效果=埏埴行[1:]
        while '' in self.效果:
            self.效果.remove('')
        for i,效果 in enumerate(self.效果):
            self.效果[i]=效果.split(' ')
        self.周天数=0
        #加成=[基础攻，阴属性基础攻，阳属性基础攻，本周天该阵法攻击加成增加]
        self.加成=[0,0,0,0]
        self.目标=''
        if self.埏埴id in ['3533','3553']:
            self.目标=self.埏埴id

    def 埏埴效果(self): #sz_index
        效果结算(self)
        self.周天数+=1


# json?
天元字典={}
for 天元行 in 天元表[1:]:
    天元字典[天元行[0]]=[int(天元行[1]),int(天元行[2])]

玩家棋子字典1={}
for 棋子行 in 棋子表1[1:]:
    玩家棋子字典1[棋子行[0]+棋子行[1]+棋子行[2]]=棋子(棋子行)

玩家棋子字典2={}
for 棋子行 in 棋子表2[1:]:
    玩家棋子字典2[棋子行[0]+棋子行[1]+棋子行[2]]=棋子(棋子行)

玩家1=玩家('玩家1',玩家棋子字典1)
玩家2=玩家('玩家2',玩家棋子字典2)

埏埴字典={}
for 埏埴行 in 埏埴表[1:]:
    埏埴字典[埏埴行[0]]=埏埴(埏埴行)

场上阵法字典={}


# 规则

def 阵法下子判断(阵法,棋子):
    if 棋子.埏埴数==3: # 加个proxy
        return len(阵法.阵法埏埴()) in [0,2,4,6]
    else:
        return True

def 玩家判断(玩家,阵法,阶段):
    if 阶段=='下子':
        return 阵法.玩家==玩家.玩家id
    else:
        return 阵法.玩家!=玩家.玩家id

def 机会规则(玩家,棋子):
    if 棋子.埏埴数>1:
        return (0,棋子.埏埴数-1)
    else:
        if 玩家.机会[1]>0:
            return (1,1)
        elif 玩家.机会[2]>0:
            return (2,1)
        else:
            return (0,0)
        
def 机会判断(棋子,玩家): 
    return 玩家.机会[机会规则(玩家,棋子)[0]]>=机会规则(玩家,棋子)[1] and 机会规则(玩家,棋子)[1]>0

def 机会计算(玩家,棋子):
    玩家.机会[机会规则(玩家,棋子)[0]]-=机会规则(玩家,棋子)[1]
    print(玩家.机会)


#结算效果

def 效果结算(埏埴):
    if '基础攻' in 埏埴.效果[0]: #['基础攻',[{k|mk,n},{n|mk,n},基础攻(%)],...]
        for 效果 in 埏埴.效果[1:]:
            if 埏埴.周天数 in range(int(效果[0]),int(效果[1])):
                if 埏埴.阴阳=='':
                    埏埴.加成[0]+=int(效果[2])
                elif 埏埴.阴阳=='阴':
                    埏埴.加成[1]+=int(效果[2])
                elif 埏埴.阴阳=='阳':
                    埏埴.加成[2]+=int(效果[2])
                elif 埏埴.阴阳=='总':
                    埏埴.加成[3]+=int(效果[2])
    elif '阵法气' in 埏埴.效果[0]: #['阵法气',[{k|mk,n},{n|mk,n},气(+/-)],...]
        for 效果 in 埏埴.效果[1:]:
            if 埏埴.周天数 in range(int(效果[0]),int(效果[1])):
                场上阵法字典[埏埴.阵法id].气+=int(效果[2])
    elif '延缓' in 埏埴.效果[0]: # 有问题
        目标埏埴=埏埴字典[埏埴.目标]
        for i,效果 in enumerate(目标埏埴.效果[1:]):
            if 目标埏埴.周天数>效果[0]:
                目标埏埴.效果[1:][i][0]=目标埏埴.周天数
        目标埏埴.周天数-=1

    #延缓机会,废子机会,提子 没做
    

# 阶段方法

def 准备阶段():
    for 阵法条 in list(场上阵法字典.items()):
        if 阵法条[1].气<=0:
            for 埏埴 in 阵法条[1].阵法埏埴():
                埏埴.周天数=0
                埏埴.加成=[0,0,0,0]
            del 场上阵法字典[阵法条[0]]
    玩家1.机会=[3,1,玩家1.机会[2]]
    玩家2.机会=[3,1,玩家2.机会[2]]
    #玩家1.机会[2]=1


def 下子阶段(玩家):
    while input('结束？')!='结束':
        棋子=玩家.玩家棋子字典[input('请输入棋子id:')]
        输入=input('输入:')
        if 输入=='建立阵法':
            玩家.建立阵法(棋子)
        elif 输入=='下子':
            阵法=场上阵法字典[input('请输入阵法id:')]
            if 玩家判断(玩家,阵法,'下子'):
                玩家.下子(棋子,阵法)
            else:
                print('本阶段不能下在这里')
    


def 周天和结算():
    for 目标阵法 in 场上阵法字典.items():
        #周天的每个空星位-1气
        if min(8,目标阵法[1].周天位+目标阵法[1].周天数)-len(目标阵法[1].阵法埏埴())>0: #本周天有空星位
            场上阵法字典[目标阵法[0]].气-=max(min(8,目标阵法[1].周天位+目标阵法[1].周天数)-len(目标阵法[1].阵法埏埴()),目标阵法[1].周天数) #减气

        if int(目标阵法[1].周天位+目标阵法[1].周天数)>=8: #if写进list comprehension里出问题，list[0:-1]?
            [目标埏埴.埏埴效果() for 目标埏埴 in 目标阵法[1].阵法埏埴()[int(目标阵法[1].周天位):8]]
            场上阵法字典[目标阵法[0]].周天位=(目标阵法[1].周天位+目标阵法[1].周天数)%8
            [目标埏埴.埏埴效果() for 目标埏埴 in 目标阵法[1].阵法埏埴()[0:int(场上阵法字典[目标阵法[0]].周天位)]]
        else:
            [目标埏埴.埏埴效果() for 目标埏埴 in 目标阵法[1].阵法埏埴()[int(目标阵法[1].周天位):int(目标阵法[1].周天位+目标阵法[1].周天数)]]
            场上阵法字典[目标阵法[0]].周天位=(目标阵法[1].周天位+目标阵法[1].周天数)%8
        
        

def 结束(玩家):
    while input('结束？')!='结束':
        棋子=input('棋子?: ')
        阵法=场上阵法字典[input('请输入阵法id:')]
        if 玩家判断(玩家,阵法,'结束'):
            玩家.下子(棋子,阵法)
        else:
            print('本阶段不能下在这里')
        # 回合限定机会清除
        # 回合限定效果移除


# 测试
准备阶段()
下子阶段(玩家1)
周天和结算()
